/*
 * The Blue Alliance API v3
 *
 * # Overview    Information and statistics about FIRST Robotics Competition
 * teams and events.   # Authentication   All endpoints require an Auth Key
 * to be passed in the header `X-TBA-Auth-Key`. If you do not have an auth
 * key yet, you can obtain one from your [Account Page](/account).
 *
 * The version of the OpenAPI document: 3.9.13
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`get_district_awards`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDistrictAwardsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_district_events`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDistrictEventsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_district_events_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDistrictEventsKeysError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_district_events_simple`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDistrictEventsSimpleError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_advancement_points`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventAdvancementPointsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_alliances`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventAlliancesError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_awards`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventAwardsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_coprs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventCoprsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_district_points`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventDistrictPointsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_insights`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventInsightsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_match_timeseries`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventMatchTimeseriesError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_matches`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventMatchesError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_matches_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventMatchesKeysError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_matches_simple`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventMatchesSimpleError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_oprs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventOprsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_predictions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventPredictionsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_rankings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventRankingsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_simple`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventSimpleError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_team_media`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventTeamMediaError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_teams`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventTeamsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_teams_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventTeamsKeysError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_teams_simple`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventTeamsSimpleError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_teams_statuses`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventTeamsStatusesError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_events_by_year`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventsByYearError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_events_by_year_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventsByYearKeysError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_events_by_year_simple`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventsByYearSimpleError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_regional_champs_pool_points`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRegionalChampsPoolPointsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_team_event_awards`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamEventAwardsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_team_event_matches`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamEventMatchesError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_team_event_matches_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamEventMatchesKeysError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_team_event_matches_simple`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamEventMatchesSimpleError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_team_event_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamEventStatusError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_team_events`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamEventsError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_team_events_by_year`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamEventsByYearError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_team_events_by_year_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamEventsByYearKeysError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_team_events_by_year_simple`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamEventsByYearSimpleError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_team_events_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamEventsKeysError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_team_events_simple`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamEventsSimpleError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_team_events_statuses_by_year`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTeamEventsStatusesByYearError {
    Status401(models::GetStatus401Response),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// Gets a list of awards in the given district.
pub async fn get_district_awards(
    configuration: &configuration::Configuration,
    district_key: &str,
) -> Result<Vec<models::Award>, Error<GetDistrictAwardsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_district_key = district_key;

    let uri_str = format!(
        "{}/district/{district_key}/awards",
        configuration.base_path,
        district_key = crate::apis::urlencode(p_district_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Award&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Award&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDistrictAwardsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of events in the given district.
pub async fn get_district_events(
    configuration: &configuration::Configuration,
    district_key: &str,
) -> Result<Vec<models::Event>, Error<GetDistrictEventsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_district_key = district_key;

    let uri_str = format!(
        "{}/district/{district_key}/events",
        configuration.base_path,
        district_key = crate::apis::urlencode(p_district_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Event&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Event&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDistrictEventsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of event keys for events in the given district.
pub async fn get_district_events_keys(
    configuration: &configuration::Configuration,
    district_key: &str,
) -> Result<Vec<String>, Error<GetDistrictEventsKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_district_key = district_key;

    let uri_str = format!(
        "{}/district/{district_key}/events/keys",
        configuration.base_path,
        district_key = crate::apis::urlencode(p_district_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDistrictEventsKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a short-form list of events in the given district.
pub async fn get_district_events_simple(
    configuration: &configuration::Configuration,
    district_key: &str,
) -> Result<Vec<models::EventSimple>, Error<GetDistrictEventsSimpleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_district_key = district_key;

    let uri_str = format!(
        "{}/district/{district_key}/events/simple",
        configuration.base_path,
        district_key = crate::apis::urlencode(p_district_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::EventSimple&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::EventSimple&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDistrictEventsSimpleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets an Event.
pub async fn get_event(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<models::Event, Error<GetEventError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Event`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Event`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Depending on the type of event (district/regional), this will return either
/// district points or regional CMP points
pub async fn get_event_advancement_points(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<models::EventDistrictPoints, Error<GetEventAdvancementPointsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/advancement_points",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::EventDistrictPoints`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::EventDistrictPoints`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventAdvancementPointsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of Elimination Alliances for the given Event.
pub async fn get_event_alliances(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<Vec<models::EliminationAlliance>, Error<GetEventAlliancesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/alliances",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::EliminationAlliance&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::EliminationAlliance&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventAlliancesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of awards from the given event.
pub async fn get_event_awards(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<Vec<models::Award>, Error<GetEventAwardsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/awards",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Award&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Award&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventAwardsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a set of Event Component OPRs for the given Event.
pub async fn get_event_coprs(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<
    std::collections::HashMap<String, std::collections::HashMap<String, f64>>,
    Error<GetEventCoprsError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/coprs",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, std::collections::HashMap&lt;String, f64&gt;&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, std::collections::HashMap&lt;String, f64&gt;&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventCoprsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of district points for the Event. These are always calculated,
/// regardless of event type, and may/may not be actually useful.
pub async fn get_event_district_points(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<models::EventDistrictPoints, Error<GetEventDistrictPointsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/district_points",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::EventDistrictPoints`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::EventDistrictPoints`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventDistrictPointsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a set of Event-specific insights for the given Event.
pub async fn get_event_insights(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<models::EventInsights, Error<GetEventInsightsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/insights",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::EventInsights`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::EventInsights`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventInsightsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets an array of Match Keys for the given event key that have timeseries
/// data. Returns an empty array if no matches have timeseries data. *WARNING:*
/// This is *not* official data, and is subject to a significant possibility of
/// error, or missing data. Do not rely on this data for any purpose. In fact,
/// pretend we made it up. *WARNING:* This endpoint and corresponding data
/// models are under *active development* and may change at any time, including
/// in breaking ways.
pub async fn get_event_match_timeseries(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<Vec<String>, Error<GetEventMatchTimeseriesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/matches/timeseries",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventMatchTimeseriesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of matches for the given event.
pub async fn get_event_matches(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<Vec<models::Match>, Error<GetEventMatchesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/matches",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Match&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Match&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventMatchesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of match keys for the given event.
pub async fn get_event_matches_keys(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<Vec<String>, Error<GetEventMatchesKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/matches/keys",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventMatchesKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a short-form list of matches for the given event.
pub async fn get_event_matches_simple(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<Vec<models::MatchSimple>, Error<GetEventMatchesSimpleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/matches/simple",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::MatchSimple&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::MatchSimple&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventMatchesSimpleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a set of Event OPRs (including OPR, DPR, and CCWM) for the given Event.
pub async fn get_event_oprs(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<models::EventOprs, Error<GetEventOprsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/oprs",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::EventOprs`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::EventOprs`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventOprsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets information on TBA-generated predictions for the given Event. Contains
/// year-specific information. *WARNING* This endpoint is currently under
/// development and may change at any time.
pub async fn get_event_predictions(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<serde_json::Value, Error<GetEventPredictionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/predictions",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventPredictionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of team rankings for the Event.
pub async fn get_event_rankings(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<models::EventRanking, Error<GetEventRankingsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/rankings",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::EventRanking`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::EventRanking`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventRankingsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a short-form Event.
pub async fn get_event_simple(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<models::EventSimple, Error<GetEventSimpleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/simple",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::EventSimple`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::EventSimple`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventSimpleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of media objects that correspond to teams at this event.
pub async fn get_event_team_media(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<Vec<models::Media>, Error<GetEventTeamMediaError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/team_media",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Media&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Media&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventTeamMediaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of `Team` objects that competed in the given event.
pub async fn get_event_teams(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<Vec<models::Team>, Error<GetEventTeamsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/teams",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Team&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Team&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventTeamsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of `Team` keys that competed in the given event.
pub async fn get_event_teams_keys(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<Vec<String>, Error<GetEventTeamsKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/teams/keys",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventTeamsKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a short-form list of `Team` objects that competed in the given event.
pub async fn get_event_teams_simple(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<Vec<models::TeamSimple>, Error<GetEventTeamsSimpleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/teams/simple",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TeamSimple&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TeamSimple&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventTeamsSimpleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a key-value list of the event statuses for teams competing at the given
/// event.
pub async fn get_event_teams_statuses(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<
    std::collections::HashMap<String, models::GetTeamEventsStatusesByYear200ResponseValue>,
    Error<GetEventTeamsStatusesError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/teams/statuses",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::GetTeamEventsStatusesByYear200ResponseValue&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::GetTeamEventsStatusesByYear200ResponseValue&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventTeamsStatusesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of events in the given year.
pub async fn get_events_by_year(
    configuration: &configuration::Configuration,
    year: i32,
) -> Result<Vec<models::Event>, Error<GetEventsByYearError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_year = year;

    let uri_str = format!("{}/events/{year}", configuration.base_path, year = p_year);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Event&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Event&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventsByYearError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of event keys in the given year.
pub async fn get_events_by_year_keys(
    configuration: &configuration::Configuration,
    year: i32,
) -> Result<Vec<String>, Error<GetEventsByYearKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_year = year;

    let uri_str = format!(
        "{}/events/{year}/keys",
        configuration.base_path,
        year = p_year
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventsByYearKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a short-form list of events in the given year.
pub async fn get_events_by_year_simple(
    configuration: &configuration::Configuration,
    year: i32,
) -> Result<Vec<models::EventSimple>, Error<GetEventsByYearSimpleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_year = year;

    let uri_str = format!(
        "{}/events/{year}/simple",
        configuration.base_path,
        year = p_year
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::EventSimple&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::EventSimple&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventsByYearSimpleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// For 2025+ Regional events, this will return points towards the Championship
/// qualification pool.
pub async fn get_regional_champs_pool_points(
    configuration: &configuration::Configuration,
    event_key: &str,
) -> Result<models::EventDistrictPoints, Error<GetRegionalChampsPoolPointsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/event/{event_key}/regional_champs_pool_points",
        configuration.base_path,
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::EventDistrictPoints`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::EventDistrictPoints`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRegionalChampsPoolPointsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of awards the given team won at the given event.
pub async fn get_team_event_awards(
    configuration: &configuration::Configuration,
    team_key: &str,
    event_key: &str,
) -> Result<Vec<models::Award>, Error<GetTeamEventAwardsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_key = team_key;
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/team/{team_key}/event/{event_key}/awards",
        configuration.base_path,
        team_key = crate::apis::urlencode(p_team_key),
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Award&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Award&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamEventAwardsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of matches for the given team and event.
pub async fn get_team_event_matches(
    configuration: &configuration::Configuration,
    team_key: &str,
    event_key: &str,
) -> Result<Vec<models::Match>, Error<GetTeamEventMatchesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_key = team_key;
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/team/{team_key}/event/{event_key}/matches",
        configuration.base_path,
        team_key = crate::apis::urlencode(p_team_key),
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Match&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Match&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamEventMatchesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of match keys for matches for the given team and event.
pub async fn get_team_event_matches_keys(
    configuration: &configuration::Configuration,
    team_key: &str,
    event_key: &str,
) -> Result<Vec<String>, Error<GetTeamEventMatchesKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_key = team_key;
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/team/{team_key}/event/{event_key}/matches/keys",
        configuration.base_path,
        team_key = crate::apis::urlencode(p_team_key),
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamEventMatchesKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a short-form list of matches for the given team and event.
pub async fn get_team_event_matches_simple(
    configuration: &configuration::Configuration,
    team_key: &str,
    event_key: &str,
) -> Result<Vec<models::Match>, Error<GetTeamEventMatchesSimpleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_key = team_key;
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/team/{team_key}/event/{event_key}/matches/simple",
        configuration.base_path,
        team_key = crate::apis::urlencode(p_team_key),
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Match&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Match&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamEventMatchesSimpleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets the competition rank and status of the team at the given event.
pub async fn get_team_event_status(
    configuration: &configuration::Configuration,
    team_key: &str,
    event_key: &str,
) -> Result<models::TeamEventStatus, Error<GetTeamEventStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_key = team_key;
    let p_event_key = event_key;

    let uri_str = format!(
        "{}/team/{team_key}/event/{event_key}/status",
        configuration.base_path,
        team_key = crate::apis::urlencode(p_team_key),
        event_key = crate::apis::urlencode(p_event_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::TeamEventStatus`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::TeamEventStatus`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamEventStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of all events this team has competed at.
pub async fn get_team_events(
    configuration: &configuration::Configuration,
    team_key: &str,
) -> Result<Vec<models::Event>, Error<GetTeamEventsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_key = team_key;

    let uri_str = format!(
        "{}/team/{team_key}/events",
        configuration.base_path,
        team_key = crate::apis::urlencode(p_team_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Event&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Event&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamEventsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of events this team has competed at in the given year.
pub async fn get_team_events_by_year(
    configuration: &configuration::Configuration,
    team_key: &str,
    year: i32,
) -> Result<Vec<models::Event>, Error<GetTeamEventsByYearError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_key = team_key;
    let p_year = year;

    let uri_str = format!(
        "{}/team/{team_key}/events/{year}",
        configuration.base_path,
        team_key = crate::apis::urlencode(p_team_key),
        year = p_year
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Event&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Event&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamEventsByYearError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of the event keys for events this team has competed at in the
/// given year.
pub async fn get_team_events_by_year_keys(
    configuration: &configuration::Configuration,
    team_key: &str,
    year: i32,
) -> Result<Vec<String>, Error<GetTeamEventsByYearKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_key = team_key;
    let p_year = year;

    let uri_str = format!(
        "{}/team/{team_key}/events/{year}/keys",
        configuration.base_path,
        team_key = crate::apis::urlencode(p_team_key),
        year = p_year
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamEventsByYearKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a short-form list of events this team has competed at in the given
/// year.
pub async fn get_team_events_by_year_simple(
    configuration: &configuration::Configuration,
    team_key: &str,
    year: i32,
) -> Result<Vec<models::EventSimple>, Error<GetTeamEventsByYearSimpleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_key = team_key;
    let p_year = year;

    let uri_str = format!(
        "{}/team/{team_key}/events/{year}/simple",
        configuration.base_path,
        team_key = crate::apis::urlencode(p_team_key),
        year = p_year
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::EventSimple&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::EventSimple&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamEventsByYearSimpleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of the event keys for all events this team has competed at.
pub async fn get_team_events_keys(
    configuration: &configuration::Configuration,
    team_key: &str,
) -> Result<Vec<String>, Error<GetTeamEventsKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_key = team_key;

    let uri_str = format!(
        "{}/team/{team_key}/events/keys",
        configuration.base_path,
        team_key = crate::apis::urlencode(p_team_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamEventsKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a short-form list of all events this team has competed at.
pub async fn get_team_events_simple(
    configuration: &configuration::Configuration,
    team_key: &str,
) -> Result<Vec<models::EventSimple>, Error<GetTeamEventsSimpleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_key = team_key;

    let uri_str = format!(
        "{}/team/{team_key}/events/simple",
        configuration.base_path,
        team_key = crate::apis::urlencode(p_team_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::EventSimple&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::EventSimple&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamEventsSimpleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a key-value list of the event statuses for events this team has
/// competed at in the given year.
pub async fn get_team_events_statuses_by_year(
    configuration: &configuration::Configuration,
    team_key: &str,
    year: i32,
) -> Result<
    std::collections::HashMap<String, models::GetTeamEventsStatusesByYear200ResponseValue>,
    Error<GetTeamEventsStatusesByYearError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_team_key = team_key;
    let p_year = year;

    let uri_str = format!(
        "{}/team/{team_key}/events/{year}/statuses",
        configuration.base_path,
        team_key = crate::apis::urlencode(p_team_key),
        year = p_year
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TBA-Auth-Key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::GetTeamEventsStatusesByYear200ResponseValue&gt;`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::GetTeamEventsStatusesByYear200ResponseValue&gt;`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTeamEventsStatusesByYearError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
